#!/usr/bin/python3

# Skyward Build System Configuration File
#
# Copyright (c) 2015-2019 Skyward Experimental Rocketry
# Authors: Alain Carlucci, Alvise de'Faveri Tron
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#
# This script provides a way to automatically build and execute Makefiles
# for Miosix.
# The script searches for an sbs.conf file in the directory in which it is executed.
# The .conf file tells the script:
# - where are the files containing a "main()", divided in entrypoints and tests
# - for each main, which target board to set
# - for each main, which DEFINE flags to set
# - for each main, which additional .cpp files have to be compiled (srcfiles)
# - for all files, which additional folders to include and/or static libraries
# - the relative path to this folder
#

from optparse import OptionParser
import os, shutil, subprocess, sys, time

try:
    import ConfigParser as cp #python 2
except ImportError:
    import configparser as cp #python 3

#
# Global variables
#
srcfiles={}
extlibs={}
mainfiles={}
colors=False

# Map for the project configuration, filled in when parsing sbs.conf
projconf = {
    "ENTRY_PATH":"src/entrypoints",
    "TESTS_PATH":"src/tests",
    "SRC_PATH":"src/shared",
    "SBS_BASE": ".",
    "PROJECT_INCLUDES": "",
    "PROJECT_SUBDIRS": "",
    "PROJECT_LIBS": ""
}

#
# ASCII art banner
#
def printBanner():
    print("+---------------------------------------------------------------+")
    print("|   ____  _                                _                    |")
    print("|  / ___|| | ___   ___      ____ _ _ __ __| |                   |")
    print("|  \\___ \\| |/ / | | \\ \\ /\\ / / _` | '__/ _` |                   |")
    print("|   ___) |   <| |_| |\\ V  V / (_| | | | (_| |                   |")
    print("|  |____/|_|\\_\\\\__, | \\_/\\_/ \\__,_|_|  \\__,_|                   |")
    print("|   ____       |___/    _   ____            _                   |")
    print("|  | __ ) _   _(_) | __| | / ___| _   _ ___| |_ ___ _ __ ___    |")
    print("|  |  _ \\| | | | | |/ _` | \\___ \\| | | / __| __/ _ \\ '_ ` _ \\   |")
    print("|  | |_) | |_| | | | (_| |  ___) | |_| \\__ \\ ||  __/ | | | | |  |")
    print("|  |____/ \\__,_|_|_|\\__,_| |____/ \\__, |___/\\__\\___|_| |_| |_|  |")
    print("+----------------------------------|___/-------------------v2.0-+")

#
# Colorized output helper functions
# NOTE: I don't know why but an extra \n is added at the end of each line,
# so we have to use replace
#
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)
NORMAL, BOLD, DIM, NONE1, UNDERLINED, BLINK, NONE2, REVERSE, HIDDEN = range(9)
def printout(text, colour=WHITE,style=NORMAL):
    if colors:
        seq = "\x1b[%d;%dm" % (style,30+colour) + text + "\x1b[0m"
        print(seq.replace('\n','',1), flush=True)
    else:
        print(text.replace('\n','',1), flush=True)

def print_make_output(text):
    if "error" in text:
        printout(text, RED, BOLD)
    elif "warning" in text:
        printout(text, YELLOW, BOLD)
    elif "note" in text:
        printout(text, BLUE)
    else:
        print(text.replace('\n','',1), flush=True)

#
# Define all command line options
#
def configCmdParser():
    parser = OptionParser()
    parser.add_option("-c", "--clean", help="Run a 'make clean'", dest="clean",
        action="store_true")
    parser.add_option("-b", "--build", help="Build a specific entrypoint or test", dest="board")
    parser.add_option("-l", "--list", help="List all possible configurations", dest="list",
        default=False, action='store_true')
    parser.add_option("-t", "--all-test", help="Build all tests", dest="all_tests",
        default=False, action='store_true')
    parser.add_option("-e", "--all-entrypoint", help="Build all entrypoints", dest="all_entry",
        default=False, action='store_true')
#    parser.add_option("-g", "--gen-faults", help="Generate fault list header files and exit",
#        dest="genhdr", default=False, action='store_true')
    parser.add_option("-v", "--verbose", help="Print a verbose output", dest="log",
        action="store_true")
    parser.add_option("", "--lint", help="Run the linter", dest="lint",
        action="store_true")
    parser.add_option("-j", "--jobs",
        help="Specifies the number of jobs (commands) to run simultaneously.",
        type="int", dest="JOBS", default=8)
    parser.add_option("-n", "--no-colors", help="Don't print colors in the output", dest="colors",
        default=True,  action="store_false")
    return parser

#
# Parse the sbs.conf file: project-level config, entrypoints, tests and srcfiles
#
def parseConf(path):
    global projconf
    entrypoint_mask = projconf['ENTRY_PATH'] + "/%s.cpp"
    test_mask = projconf['TESTS_PATH'] + "/%s.cpp"

    # Parse .conf file
    conf = cp.RawConfigParser()
    conf.read(path)

    # Read all sections
    for i in conf.sections():
        stype = conf.get(i, 'Type')

        if stype == 'project':
            # Put all the project conf values in the corresponding map
            for i in projconf:
                projconf[i] = conf.get('SBS_PROJECT', i)
        elif stype == 'srcfiles':
            srcfiles[i] = [x.strip() for x in conf.get(i, 'Files').split("\n")]
        elif stype == 'library':
            extlibs[i] = {'subdir': conf.get(i, 'Subdir'),
                          'libs': [x.strip() for x in conf.get(i, 'Libs').split()],
                          'includes': [x.strip() for x in conf.get(i, 'Includes').split()]}
        elif stype == 'board' or stype == 'test':
            if stype == 'test':
                mask = test_mask
                add_def = " -I" + projconf['TESTS_PATH']
            else:
                mask = entrypoint_mask
                add_def = ""
            
            mainfiles[i] = {'type': stype,
                            'id': conf.get(i, 'BoardId').strip(),
                            'bin': conf.get(i, 'BinName'),
                            'defines': conf.get(i, 'Defines') + add_def,
                            'libs': [x.strip() for x in conf.get(i, 'Libs', fallback="").split()],
                            'files': [mask % conf.get(i, 'Main').strip()] +
                             [x.strip() for x in conf.get(i, 'Include').split(' ')]
                        }
        else:
            print('[SBS] Syntax error in %s: type %s not implemented' % (path, stype))
            exit(1)


    # Exit if nothing was found
    if (len(mainfiles) == 0 ):
        print('[SBS] Nothing found in sbs.conf . Terminating.')
        exit(1)

    # Import also srcfiles from boardcore if executing from another folders
    if projconf['SBS_BASE'] != '.':
        importSrcFiles(projconf['SBS_BASE'] + "/sbs.conf")
        importLibs(projconf['SBS_BASE'] + "/sbs.conf")

    # Substitute includes
    for i in mainfiles:
        files = []
        for j in mainfiles[i]['files']:
            if j.startswith('%'):
                files += srcfiles[j[1:]]
            else:
                files += [j]
        mainfiles[i]['files'] = files
    
    # Substitute libs
    for i in mainfiles:
        lib_dicts = {}
        for j in mainfiles[i]['libs']:
            lib_dicts[j] = extlibs[j]
        mainfiles[i]['libs'] = lib_dicts

#
# Create a Makefile for a specific board starting from Makefile.template
#
def build_makefile(template, board, bname):
    global projconf
    incllist = projconf["PROJECT_INCLUDES"].split()
    liblist = projconf["PROJECT_LIBS"].split()
    subdirs = projconf["PROJECT_SUBDIRS"].split()

    rmap = { "BOARD_DEFINE": "export OPT_BOARD := %s\nexport BOARD_UUID := %s\n" % (board['id'], bname),
             "MAP_FILE": "export MAIN_MAP_FILE := bin/%s.map\n" % board['bin'],
             "SOURCE_FILES": "%s\n" % (" ".join(board['files'])),
             "CUSTOM_DEFINES": board['defines'],
             "BIN_NAME": board['bin'],
             "LIB_SUBDIR": " ".join([x['subdir'] for _,x in board['libs'].items()]),
             "LIB_LIBS": " ".join([" ".join(x['libs']) for _,x in board['libs'].items()]),
             "LIB_INCLUDES": " ".join([" ".join([ "-I" + s for s in x['includes']]) for _,x in board['libs'].items()])
    }

    rmap["PROJECT_INCLUDES"] = "-I" + projconf["SRC_PATH"].strip() + " "
    rmap["PROJECT_LIBS"] = ""
    rmap["PROJECT_SUBDIRS"] = ""

    for incl in incllist:
        rmap["PROJECT_INCLUDES"] += incl.strip() + " "

    for lib in liblist:
        rmap["PROJECT_LIBS"] += lib.strip() + " "

    for sd in subdirs:
        rmap["PROJECT_SUBDIRS"] += sd.strip() + " "

    for i in rmap:
        template = template.replace("{SBS_%s}" % i , rmap[i])

    template = template.replace('{SBS_BASE_PATH}', projconf['SBS_BASE'])

    return template

#
# Generate fault counter headers
#
#def genFaultCounters():
#    d1 = "data/fault_list.csv"
#    d2 = SBS_BASE + "/src/shared/diagnostic/FaultCounterData.h"
#    os.system("python %s/scripts/gen_fault_headers.py %s %s" %(SBS_BASE,d1,d2))

#
# Import srcfiles groups from another .conf file.
# Srcfiles are added only if there's not a group already with the same name.
#
def importSrcFiles(path):
    conf = cp.RawConfigParser()
    conf.read(path)

    for i in conf.sections():
        stype = conf.get(i, 'Type')
        if stype == 'srcfiles':
            if i not in srcfiles:
                srcfiles[i] = [projconf['SBS_BASE'] + "/" + x.strip() for x in conf.get(i, 'Files').split("\n")]
            else:
                print('[SBS] Syntax error in %s: a srcfiles group named %s is already defined. Terminating' % (path, i))
                exit(1)
#
# Import libraries groups from another .conf file.
# Libraries are added only if there's not a group already with the same name.
#
def importLibs(path):
    conf = cp.RawConfigParser()
    conf.read(path)

    for i in conf.sections():
        stype = conf.get(i, 'Type')
        if stype == 'library':
            if i not in extlibs:
                extlibs[i] =  {'subdir': conf.get(i, 'Subdir'),
                            'libs': [x.strip() for x in conf.get(i, 'Libs').split()],
                            'includes': [x.strip() for x in conf.get(i, 'Includes').split()]}
            else:
                print('[SBS] Syntax error in %s: a library group named %s is already defined. Terminating' % (path, i))
                exit(1)

##-------------------------------------------------------------
##                       MAIN
##-------------------------------------------------------------

printBanner()

# Parse command line options
parser = configCmdParser()
(options, args) = parser.parse_args()
colors = options.colors

# Parse configuration file
parseConf("sbs.conf")

# Load Makefile.template
make_template = ""
with open( projconf['SBS_BASE'] + '/Makefile.template') as f:
    make_template = str(f.read())
if len(make_template) == 0:
    print('[SBS]  Makefile template empty or not found.')
    exit(1)

#
# Do things
#

# Fault headers generation
# if options.genhdr == True:
#     genFaultCounters()
#     exit(0)

# Linter
if options.lint == True:
    print("[SBS] Executing linter.sh", flush=True)
    os.system("%s/scripts/linter.sh %s" % (projconf['SBS_BASE'], projconf['SRC_PATH']) )
    sys.exit(0)

# List
if options.list == True:
    print('[SBS] List of available entrypoints:')
    for main in mainfiles:
        if(mainfiles[main]['type'] == 'board'):
            print(main)
    print('\n[SBS] List of available tests:')
    for main in mainfiles:
        if(mainfiles[main]['type'] == 'test'):
            print(main)
    exit(0)

# Set how many main files to build:
files = list(mainfiles.keys()).copy()
if options.board != None:       # just one
    try:
        good = mainfiles[options.board]
        mainfiles = {options.board : good}
    except KeyError:
        print('[SBS] No entrypoint or test named %s. Terminating.' % (options.board))
        sys.exit(2)
elif options.all_entry == True:  # all entrypoints
     for main in files:
        if(mainfiles[main]['type'] == 'test'):
            del mainfiles[main]
elif options.all_tests == True:  # all tests
    for main in files:
        if(mainfiles[main]['type'] == 'board'):
            del mainfiles[main]


# Set action
if options.clean == True:
    cleanparam =["clean"]
    action = ["Clean", "Cleaning"]
else:
    cleanparam =[]
    action = ["Build","Building"]

# Clean makefiles before building
shutil.rmtree('build',ignore_errors=True, onerror=None)
os.mkdir('build')

# Populate and execute Makefile (build or clean)

for i in mainfiles:
    printout('[SBS] %s %s' % (action[1],i), WHITE, BOLD)

    with open('build/%s' % i, 'w') as f:
        f.write(build_makefile(make_template, mainfiles[i], i))

    # stdout printed only in verbose
    if options.log == True:
        p = subprocess.Popen(['make','-j', str(options.JOBS), '-f', 'build/%s' % i]
                                + cleanparam,
                                universal_newlines=True,
                                #stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                bufsize=1)
    else:
        p = subprocess.Popen(['make', '-j', str(options.JOBS), '-f', 'build/%s' % i]
                                + cleanparam,
                                universal_newlines=True,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                bufsize=1)

    #stderr always printed
    with p.stderr:
        for line in iter(p.stderr.readline, ''):
            print_make_output(line)

    while p.returncode == None:
        p.poll()

    if p.returncode != 0:
        printout('[SBS] %s Failed. Terminating.' % action[0], RED, REVERSE)
        sys.exit(-1)
    else:
        printout('[SBS] %s OK - %s\n\n' % (action[0],i), GREEN, BOLD)

# Clean
if options.clean == True:
    shutil.rmtree('build',ignore_errors=True, onerror=None)