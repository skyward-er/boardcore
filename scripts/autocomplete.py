# Copyright (c) 2024 Skyward Experimental Rocketry
# Author: Davide Basso
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os
import sys
import inspect
import platform
from shutil import which
from pathlib import Path

LINUX_BASH_COMPLETION_FOLDER = "/etc/bash_completion.d"
SBS_AUTOCOMPLETE_FOLDER = "sbs"
SBS_AUTOCOMPLETE_MAIN = "sbs-autocomplete.sh"
COMMANDS = [
    "build",
    "clean",
    "flash",
    "run",
    "list",
    "test",
    "lint",
    "format",
    "install",
    "uninstall",
]
COMMANDS_WITH_TARGET = ["build", "flash", "run", "test"]


def strip_extension(file: str):
    return os.path.splitext(file)[0]


def write_autocomplete_script(file, project_name: str, targets: list[str]):
    bash = inspect.cleandoc(
        f"""#!/bin/bash
        # Skyward Build System autocompletion script
        # This script is automatically generated by sbs
        # Do not edit manually

        _sbs_{project_name}()
        {{
            local cur prev starting cmds cmds_with_target targets
            COMPREPLY=()
            cur="${{COMP_WORDS[COMP_CWORD]}}"
            prev="${{COMP_WORDS[COMP_CWORD-1]}}"
            starting="${{COMP_WORDS[0]}}"

            cmds=({' '.join([f'"{c}"' for c in COMMANDS])})
            cmds_with_target=({' '.join([f'"{c}"' for c in COMMANDS_WITH_TARGET])})
            targets=({' '.join([f'"{t}"' for t in targets])})
            
            if [[ ${{prev}} == "./sbs" ]] ; then
                COMPREPLY=( $(compgen -W "{' '.join(COMMANDS)}" -- "${{cur}}") )
            elif [[ ${{starting}} == "./sbs" && " ${{cmds_with_target[*]}} " =~ [[:space:]]${{prev}}[[:space:]] ]]; then
                COMPREPLY=( $(compgen -W "{' '.join(targets)}" -- "${{cur}}") )
            fi

            return 0
        }}
        """
    )
    file.write(bash)


def write_base_script(file):
    bash = inspect.cleandoc(
        f"""#!/bin/bash
        # Skyward Build System autocompletion script
        # This script is automatically generated by sbs
        # Do not edit manually

        _sbs__base()
        {{
            local cur prev starting cmds
            COMPREPLY=()
            cur="${{COMP_WORDS[COMP_CWORD]}}"
            prev="${{COMP_WORDS[COMP_CWORD-1]}}"
            starting="${{COMP_WORDS[1]}}"

            cmds=({' '.join([f'"{c}"' for c in COMMANDS])})
            
            if [[ ${{prev}} == sbs ]] ; then
                COMPREPLY=( $(compgen -W "{' '.join(COMMANDS)}" -- "${{cur}}") )
            fi

            return 0
        }}
        """
    )
    file.write(bash)


def write_main_script(file, folder: str, projects_scripts: list[str]):
    newline = "\n        "
    bash = inspect.cleandoc(
        f"""#!/bin/bash
        # Skyward Build System autocompletion script
        # This script is automatically generated by sbs
        # Do not edit manually

        source "{folder}/__base.sh"
        # Source into all the project scripts
        {newline.join([f'source "{folder}/{s}"' for s in projects_scripts])}

        stringContain() {{ case $2 in *$1* ) return 0;; *) return 1;; esac ;}}

        _sbs()
        {{
            local projects
            projects=({' '.join([f'"{strip_extension(s)}"' for s in projects_scripts])})

            # Check if current working directory is under any project folder
            for project in ${{projects[*]}};
            do
                if stringContain "$project" "$PWD"; then
                    _sbs_$project
                    return 0
                fi
            done

            _sbs__base

            return 0
        }}

        complete -F _sbs ./sbs
        """
    )
    file.write(bash)


def find_git_bash_completion_folder():
    # Git bash stores bash completion files inside \mingw64\share\git\completion
    # We first get the path of the git executable, and use it to find the completion folder
    git_path = which("git")
    mingw64_path = os.path.dirname(os.path.dirname(git_path))
    return os.path.join(mingw64_path, "share", "git", "completion")


def add_autocomplete_script_to_bashrc(path: str):
    home = Path.home()
    bashrc_path = os.path.join(home, ".bashrc")

    fixed_path = path.replace("\\", "/")
    cmd = f'# Skyward Build System autocompletion: \nsource "{fixed_path}"'
    # Check if the script is already sourced
    with open(bashrc_path, "r") as f:
        bashrc = f.read()
    if cmd in bashrc:
        print(f"Autocomplete script already sourced in {bashrc_path}")
        return
    # Add the script to bashrc
    with open(bashrc_path, "a") as f:
        f.write(f"\n{cmd}")
    print(f"Added autocomplete script to {bashrc_path}")


def find_folders():
    if platform.system() == "Linux":
        if not os.path.exists(LINUX_BASH_COMPLETION_FOLDER):
            raise OSError(
                f"Could not find bash completion folder {LINUX_BASH_COMPLETION_FOLDER};"
            )
        autocomplete_folder = LINUX_BASH_COMPLETION_FOLDER
        print(f"Detected Linux platform, using {autocomplete_folder}")
    elif platform.system() == "Windows":
        autocomplete_folder = find_git_bash_completion_folder()
        print(f"Detected Windows platform, using {autocomplete_folder}")
        add_autocomplete_script_to_bashrc(
            os.path.join(autocomplete_folder, SBS_AUTOCOMPLETE_MAIN)
        )
    else:
        raise OSError(f"Unsupported platform {platform.system()}")

    project_name = os.path.basename(os.getcwd())
    sbs_scripts_folder = os.path.join(autocomplete_folder, SBS_AUTOCOMPLETE_FOLDER)
    main_file_path = os.path.join(autocomplete_folder, SBS_AUTOCOMPLETE_MAIN)
    autocomplete_file_path = os.path.join(sbs_scripts_folder, project_name + ".sh")
    base_script_path = os.path.join(sbs_scripts_folder, "__base.sh")

    return (
        project_name,
        sbs_scripts_folder,
        main_file_path,
        autocomplete_file_path,
        base_script_path,
    )


def install_autocomplete(targets: list[str]):
    print(f"\nSetting up autocomplete for current project...")

    (
        project_name,
        sbs_scripts_folder,
        main_file_path,
        autocomplete_file_path,
        base_script_path,
    ) = find_folders()

    # Create paths for autocomplete scripts
    os.makedirs(sbs_scripts_folder, exist_ok=True)

    # Generate autocomplete script
    if os.path.exists(autocomplete_file_path):
        print(f"Removing old autocomplete script {autocomplete_file_path}...")
        os.remove(autocomplete_file_path)

    with open(autocomplete_file_path, "w+") as f:
        print(f"Writing autocomplete script to {autocomplete_file_path}...")
        write_autocomplete_script(f, project_name, targets)

    projects_scripts = os.listdir(sbs_scripts_folder)
    if "__base.sh" in projects_scripts:
        projects_scripts.remove("__base.sh")

    # Write base script
    if os.path.exists(base_script_path):
        print(f"Removing old base script {base_script_path}...")
        os.remove(base_script_path)

    with open(base_script_path, "w+") as f:
        print(f"Writing base script to {base_script_path}...")
        write_base_script(f)

    # Generate main script
    if os.path.exists(main_file_path):
        os.remove(main_file_path)

    with open(main_file_path, "w+") as f:
        print(f"Writing main script to {main_file_path}...")
        write_main_script(f, sbs_scripts_folder, projects_scripts)

    print(f"Done, restart your shell to see the changes\n")


def uninstall_autocomplete():
    print("Uninstalling autocomplete script...")

    (
        project_name,
        sbs_scripts_folder,
        main_file_path,
        autocomplete_file_path,
        base_script_path,
    ) = find_folders()

    if os.path.exists(autocomplete_file_path):
        print(f"Removing autocomplete script {autocomplete_file_path}...")
        os.remove(autocomplete_file_path)
    else:
        print(f"Could not find autocomplete script {autocomplete_file_path}")

    if os.path.exists(base_script_path):
        print(f"Removing base script {base_script_path}...")
        os.remove(base_script_path)
    else:
        print(f"Could not find base script {base_script_path}")

    if os.path.exists(main_file_path):
        print(f"Removing main script {main_file_path}...")
        os.remove(main_file_path)
    else:
        print(f"Could not find main script {main_file_path}")

    print("Done, restart your shell to see the changes\n")


if __name__ == "__main__":
    type = sys.argv[1]
    if type == "--install":
        install_autocomplete(sys.argv[2:])
    elif type == "--uninstall":
        uninstall_autocomplete()
    else:
        raise ValueError(f"Unknown argument {type}")
