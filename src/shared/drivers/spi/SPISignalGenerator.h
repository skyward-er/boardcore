/* Copyright (c) 2021 Skyward Experimental Rocketry
 * Author: Alberto Nidasio
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#pragma once

#include <drivers/timer/GeneralPurposeTimer.h>
#include <drivers/timer/TimerUtils.h>

#include "SPIBusInterface.h"

namespace Boardcore
{

/**
 * @brief Generates SPI clock and chip select signal through two timers chained
 * together.
 *
 * To configure which timer to use, change the following parameters:
 * - chainChannel: Specify which channel of the master timer is used to chain
 * the slave timer;
 * - csChannel: Specify which channel of the master timer to use for CS signal
 * generation;
 * - sckChannel: Specify which channel of the slave timer to use for SCK signal
 * generation.
 *
 * The chainChannel and CSChannel should be different. If they are equal the CS
 * signal generated by the master timer will be reversed (high when active).
 *
 * GPIO must be already configured.
 *
 * This driver does not support the complementary timers channels.
 */
class SPISignalGenerator
{
public:
    /**
     * @brief Create a SPISignalGenerator object. This does not configure the
     * timers.
     *
     * @param nBytes Number of bytes for the sck signal.
     * @param transactionFrequency Frequency of the SPI transactions.
     * @param spiFrequency SPI clock signal frequency.
     * @param spiMode SPI mode, this affects the clock polarity and phase.
     * @param chainChannel Master timer channel used to chain the slave timer.
     * @param csChannel Master timer channel used for CS signal generation.
     * @param sckChannel Slave timer channel used for SCK signal generation.
     * @param masterTimer Master timer which generates the CS signal.
     * @param slaveTimer Slave timer which generates the SCK signal.
     * @param slaveTriggerSource Trigger source form the slave timer. This
     * depends on the timers combination.
     */
    SPISignalGenerator(
        size_t nBytes, int transactionFrequency, int spiFrequency = 1e6,
        SPI::Mode spiMode = SPI::Mode::MODE_0,
        GeneralPurposeTimer<uint16_t>::Channel chainChannel =
            GeneralPurposeTimer<uint16_t>::Channel::CHANNEL_2,
        GeneralPurposeTimer<uint16_t>::Channel csChannel =
            GeneralPurposeTimer<uint16_t>::Channel::CHANNEL_2,
        GeneralPurposeTimer<uint16_t>::Channel sckChannel =
            GeneralPurposeTimer<uint16_t>::Channel::CHANNEL_4,
        TIM_TypeDef *masterTimer = TIM1, TIM_TypeDef *slaveTimer = TIM3,
        GeneralPurposeTimer<uint16_t>::TriggerSource slaveTriggerSource =
            GeneralPurposeTimer<uint16_t>::TriggerSource::ITR0);

    /**
     * @brief Sets up the two timers.
     */
    void configure();

    /**
     * @brief Enables SPI signal generation.
     */
    void enable();

    /**
     * @brief Disables SPI signal generation.
     */
    void disable();

    /**
     * @brief Generates a single spi transaction with the specified number of
     * bytes.
     *
     * Configures the timers to generate the specified number of bytes, enables
     * master timer one one-pulse mode and enables them. The master timer will
     * be disabled automatically, but the slave timer will not.
     *
     * @param nBytes Size of the transaction in bytes.
     */
    void generateSingleTransaction(size_t nBytes);

private:
    int nBytes;                ///< SPI Clock pulses (divided by 8).
    int transactionFrequency;  ///< Frequency of the transactions are generated.
    int spiFrequency;          ///< SPI Clock frequency.
    SPI::Mode spiMode;
    GeneralPurposeTimer<uint16_t>::Channel chainChannel;
    GeneralPurposeTimer<uint16_t>::Channel csChannel;
    GeneralPurposeTimer<uint16_t>::Channel sckChannel;
    GeneralPurposeTimer<uint16_t>
        masterTimer;  ///< Master timer for CS generation.
    GeneralPurposeTimer<uint16_t>
        slaveTimer;  ///< Slave timer for SCK generation.
    GeneralPurposeTimer<uint16_t>::TriggerSource slaveTriggerSource;
};

inline SPISignalGenerator::SPISignalGenerator(
    size_t nBytes, int transactionFrequency, int spiFrequency,
    SPI::Mode spiMode, GeneralPurposeTimer<uint16_t>::Channel chainChannel,
    GeneralPurposeTimer<uint16_t>::Channel csChannel,
    GeneralPurposeTimer<uint16_t>::Channel sckChannel, TIM_TypeDef *masterTimer,
    TIM_TypeDef *slaveTimer,
    GeneralPurposeTimer<uint16_t>::TriggerSource slaveTriggerSource)
    : nBytes(nBytes), transactionFrequency(transactionFrequency),
      spiFrequency(spiFrequency), spiMode(spiMode), chainChannel(chainChannel),
      csChannel(csChannel), sckChannel(sckChannel), masterTimer(masterTimer),
      slaveTimer(slaveTimer), slaveTriggerSource(slaveTriggerSource)
{
}

inline void SPISignalGenerator::configure()
{
    // Configure master timer
    {
        masterTimer.reset();

        // Ensures that the CS output will be high until the timers are enabled
        // masterTimer.setCounter(UINT16_MAX);

        // Connect the specified channel to the trigger output
        switch (chainChannel)
        {
            case GeneralPurposeTimer<uint16_t>::Channel::CHANNEL_1:
                masterTimer.setMasterMode(
                    GeneralPurposeTimer<uint16_t>::MasterMode::OC1REF_OUTPUT);
                break;
            case GeneralPurposeTimer<uint16_t>::Channel::CHANNEL_2:
                masterTimer.setMasterMode(
                    GeneralPurposeTimer<uint16_t>::MasterMode::OC2REF_OUTPUT);
                break;
            case GeneralPurposeTimer<uint16_t>::Channel::CHANNEL_3:
                masterTimer.setMasterMode(
                    GeneralPurposeTimer<uint16_t>::MasterMode::OC3REF_OUTPUT);
                break;
            case GeneralPurposeTimer<uint16_t>::Channel::CHANNEL_4:
                masterTimer.setMasterMode(
                    GeneralPurposeTimer<uint16_t>::MasterMode::OC4REF_OUTPUT);
                break;
        }

        // Set the prescaler and auto realod value
        uint16_t autoReloadRegister = spiFrequency * 4 / transactionFrequency;
        masterTimer.setPrescaler(TimerUtils::computePrescalerValue(
            masterTimer.getTimer(), spiFrequency * 4));
        masterTimer.setAutoReloadRegister(autoReloadRegister);

        // Set channels capture/compare register
        uint16_t ccRegister = nBytes * 8 * 4;
        ccRegister          = autoReloadRegister - ccRegister + 1;

        // Set chain channel
        masterTimer.setCaptureCompareRegister(ccRegister, chainChannel);
        masterTimer.setOutputCompareMode(
            GeneralPurposeTimer<uint16_t>::OutputCompareMode::PWM_MODE_2,
            chainChannel);

        // Set CS channel if different
        if (chainChannel != csChannel)
        {
            masterTimer.setCaptureCompareRegister(ccRegister, csChannel);
            masterTimer.setOutputCompareMode(
                GeneralPurposeTimer<uint16_t>::OutputCompareMode::PWM_MODE_1,
                csChannel);

            // Enable CS capture/compare output
            masterTimer.enableCaptureCompareOutput(csChannel);
        }
        else
        {
            // If chain channel and cs channel are the same, the cs output
            // must be from the complementary output
            masterTimer.enableCaptureCompareComplementaryOutput(chainChannel);
            masterTimer.setCaptureCompareComplementaryPolarity(
                GeneralPurposeTimer<
                    uint16_t>::OutputComparePolarity::ACTIVE_LOW,
                chainChannel);
        }

        // Update the registers
        masterTimer.generateUpdate();
    }

    // Configure slave timer
    {
        slaveTimer.reset();

        // Set slaveTimer in gated mode
        slaveTimer.setSlaveMode(
            GeneralPurposeTimer<uint16_t>::SlaveMode::GATED_MODE);

        // Set ITR1 as internal trigger source
        slaveTimer.setTriggerSource(slaveTriggerSource);

        // Set the prescaler and auto realod value
        slaveTimer.setPrescaler(TimerUtils::computePrescalerValue(
            slaveTimer.getTimer(), spiFrequency * 4));
        slaveTimer.setAutoReloadRegister(1);

        // Set SCK capture/compare register
        slaveTimer.setCaptureCompareRegister(1, sckChannel);

        // Set channel 1 to toggle mode
        slaveTimer.setOutputCompareMode(
            GeneralPurposeTimer<uint16_t>::OutputCompareMode::TOGGLE,
            sckChannel);
        if (spiMode >= SPI::Mode::MODE_2)
        {
            slaveTimer.setCaptureComparePolarity(
                GeneralPurposeTimer<
                    uint16_t>::OutputComparePolarity::ACTIVE_LOW,
                sckChannel);
        }

        // Enable capture/compare output
        slaveTimer.enableCaptureCompareOutput(sckChannel);

        // Update the register
        slaveTimer.generateUpdate();
    }
}

inline void SPISignalGenerator::enable()
{
    slaveTimer.enable();
    masterTimer.enable();
}

inline void SPISignalGenerator::disable()
{
    masterTimer.disable();
    slaveTimer.disable();
}

inline void SPISignalGenerator::generateSingleTransaction(size_t nBytes)
{
    // Change the number of bytes to generate
    size_t backupNBytes = this->nBytes;
    this->nBytes        = nBytes;

    // Change the period to generate a transaction right away
    int backupTransactionFrequency = transactionFrequency;
    transactionFrequency           = spiFrequency * 4 / (nBytes * 8 * 4);

    // Configure the timers
    configure();

    // Enable one pulse mode
    masterTimer.enableOnePulseMode();

    // Reset nBytes
    this->nBytes         = backupNBytes;
    transactionFrequency = backupTransactionFrequency;

    // Start the signal generation
    enable();
}

}  // namespace Boardcore
