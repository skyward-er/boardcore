/* LSM9DS1 accelerometer + giroscope Driver
 *
 * Copyright (c) 2016,2020 Skyward Experimental Rocketry
 * Authors: Andrea Milluzzo
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#pragma once
#include <miosix.h>

#include <array>

#include "LSM9DS1_Data.h"
#include "drivers/spi/SPIDriver.h"

using miosix::GpioPin;
using std::array;

/**
 * @brief LSM9DS1 gyro+axel+temp sensor driver.
 * provides access to data generated by the sensor using SPI protocol.
 * it is possible to set the sensor to have simple data samples or
 * exploiting integrated FIFO and perform on-interrupt reading.
 */

class LSM9DS1_XLG : public GyroSensor,
                    public AccelSensor,
                    public TemperatureSensor
{
public:
    enum AxelFSR : uint8_t
    {
        FS_2  = 0x00,  // +/- 2g
        FS_16 = 0x01,  // +/- 16g
        FS_4  = 0x02,  // +/- 4g
        FS_8  = 0x03   // +/- 8g
    };

    enum GyroFSR : uint8_t
    {
        FS_245  = 0x00,  // +/- 245dps
        FS_500  = 0x01,  // +/- 500dps
        FS_2000 = 0x03   // +/- 2000dps
    };

    enum ODR : uint8_t
    {
        PWR_DW  = 0X00,  // power down
        ODR_15  = 0X01,  // 15Hz
        ODR_60  = 0X02,  // 60Hz
        ODR_119 = 0X03,  // 119Hz
        ODR_238 = 0X04,  // 238Hz
        ODR_476 = 0X05,  // 476Hz
        ODR_952 = 0X06   // 952Hz
    };

    // clang-format off

    //Sesitivity Map (axelFSR)
    const std::map<AxelFSR, float> axelFSR_SMap{{FS_2,  0.000598f},
                                                {FS_4,  0.001196f},
                                                {FS_8,  0.002393f},
                                                {FS_16, 0.007178f}};
    
    //Sesitivity Map (gyroFSR)
    const std::map<GyroFSR, float> gyroFSR_SMap{{FS_245,  0.0001527f},
                                                {FS_500,  0.0003054f},
                                                {FS_2000, 0.0012217f}};
    
    //ODR Map
    const std::map<ODR, float> odr_Map{{PWR_DW,  0.0f  },
                                       {ODR_15,  14.9f },
                                       {ODR_60,  59.5f },
                                       {ODR_119, 119.0f},
                                       {ODR_238, 238.0f},
                                       {ODR_476, 476.0f},
                                       {ODR_952, 952.0f}};

    // clang-format on

    /**
     * @brief Creates an instance of an LSM9DS1 accelerometer + gyroscope
     * sensor.
     *
     * @param    bus SPI bus the sensor is connected to
     * @param    cs Chip Select GPIO
     * @param    axelRange accelerometer Full Scale Range (See datasheet)
     * @param    gyroRange gyroscope Full Scale Range (See datasheet)
     * @param    odr Output Data Rate (See datasheet)
     * @param    temp_div_freq Temperature update frequency division
     */

    LSM9DS1_XLG(SPIBusInterface& bus, GpioPin cs,
                AxelFSR axelRange = AxelFSR::FS_16,
                GyroFSR gyroRange = GyroFSR::FS_2000, ODR odr = ODR::ODR_952,
                uint8_t temp_div_freq = 10);

    /**
     * @brief Creates an instance of an LSM9DS1 accelerometer + gyroscope
     * sensor.
     *
     * @param    bus SPI bus the sensor is connected to
     * @param    cs Chip Select GPIO
     * @param    config (OPTIONAL) custom SPIBusConfig
     * @param    axelRange accelerometer Full Scale Range (See datasheet)
     * @param    gyroRange gyroscope Full Scale Range (See datasheet)
     * @param    odr Output Data Rate (See datasheet)
     * @param    temp_div_freq Temperature update frequency division
     */

    LSM9DS1_XLG(SPIBusInterface& bus, GpioPin cs, SPIBusConfig config,
                AxelFSR axelRange = AxelFSR::FS_16,
                GyroFSR gyroRange = GyroFSR::FS_2000, ODR odr = ODR::ODR_952,
                uint8_t temp_div_freq = 10);

    /**
     * @brief enables LSM9DS1 embedded FIFO.
     * @param fifo_watermark FIFO watermark level in range [1,32] (used for
     * interrupt generation, see datasheet).
     * @warning call before init() member
     */

    void enable_fifo(uint8_t watermark);

    /**
     * @brief initializes the LSM9DS1 Sensor (Accelerometer + Gyroscope).
     * @return true if all setup registers of the sensor have been written
     * correctly. false if already initialized, wrong who_am_i or uncorrect
     * write.
     */

    bool init() override;

    /**
     * @brief Run a self-test of the Sensor.
     * @return true if sensor behave correclty
     */

    bool selfTest() override;

    /**
     * @brief Dump single reading of Axel+Gyro+Temp from the sensor
     * (if FIFO disabled) or dump fifo_watermark samples from the FIFO (if FIFO
     * enabled) through SPI.
     * @return true if sensor sends data
     * @warning if FIFO is enabled, call only after interrupt flag from the
     * sensor has been set
     */

    bool onSimpleUpdate() override;

    /**
     * @brief set timestamp on last FIFO (if FIFO enabled) or set timestamp for
     * sample
     * @warning remember to update FIFO data calling onSimpleUpdate
     */

    void updateTimestamp(uint64_t timestamp);

    /**
     * @brief get last valid sample
     * @return sample
     */

    const lsm9ds1XLGSample& getXLGSample() const;

    /**
     * @brief get last valid sample
     * @return sample
     */

    const lsm9ds1TSample& getTSample() const;

    /**
     * @brief get FIFO dumped after calling onSimpleUpdate() - Just on FIFO
     * mode.
     * @return array containing the whole FIFO
     */

    const array<lsm9ds1XLGSample, 32>& getFIFO() const;

    /**
     * @brief get FIFO stats after calling onSimpleUpdate() - Just on FIFO
     * mode.
     * @return stats
     */

    const lsm9ds1debug& getFIFOStats() const;

    /**
     * @brief get number of samples inside the last FIFO
     * @return number of samples
     */

    const uint8_t& getFIFOdepth() const;

private:
    /**
     * @brief Dump single read of Temperature from the sensor through SPI.
     * @return true if sensor sends data
     */

    bool temperatureUpdate();

    /**
     * @brief Clear the FIFO register inside the LSM9DS1 sensor.
     * In order to perform a "clear", FIFO is disabled and then
     * re-enabled; after that some samples are discarded according to datasheet.
     */

    void clearFIFO(SPITransaction& spi);
    /**
     * @brief discard some samples from the sensor. Must be used when switching.
     * from FIFO mode to CONTINUOUS mode (or viceversa) and during power on
     */

    void discardSamples(SPITransaction& spi);

    bool sensor_initialized = false;

    bool fifo_enabled = false;
    uint8_t fifo_watermark;
    uint8_t fifo_samples;
    uint8_t last_fifo_level = 20;

    //
    uint64_t IRQ_timestamp = 0;
    uint32_t delta         = 0;

    array<lsm9ds1XLGSample, 32> fifo;
    lsm9ds1debug fifodebug;

    lsm9ds1TSample lastTemp;

    SPISlave spislave;

    AxelFSR axelFSR;
    GyroFSR gyroFSR;
    ODR odr;

    float tempZero         = 25.0f;
    float tempSensistivity = 16.0f;
    uint8_t temp_div_freq;
    uint8_t temp_count = 0;

    /**
     * @brief Registers' addresses definition.
     */
    enum regMapXLG
    {
        ACT_THS          = 0x04,
        ACT_DUR          = 0x05,
        INT_GEN_CFG_XL   = 0x06,
        INT_GEN_THS_X_XL = 0x07,
        INT_GEN_THS_Y_XL = 0x08,
        INT_GEN_THS_Z_XL = 0x09,
        INT_GEN_DUR_XL   = 0x0A,
        REFERENCE_G      = 0x0B,
        INT1_CTRL        = 0x0C,
        INT2_CTRL        = 0x0D,
        WHO_AM_I         = 0x0F,
        CTRL_REG1_G      = 0x10,
        CTRL_REG2_G      = 0x11,
        CTRL_REG3_G      = 0x12,
        ORIENT_CFG_G     = 0x13,
        INT_GEN_SRC_G    = 0x14,
        OUT_TEMP_L       = 0x15,
        OUT_TEMP_H       = 0x16,
        STATUS_REG_G     = 0x17,
        OUT_X_L_G        = 0x18,
        OUT_X_H_G        = 0x19,
        OUT_Y_L_G        = 0x1A,
        OUT_Y_H_G        = 0x1B,
        OUT_Z_L_G        = 0x1C,
        OUT_Z_H_G        = 0x1D,
        CTRL_REG4        = 0x1E,
        CTRL_REG5_XL     = 0x1F,
        CTRL_REG6_XL     = 0x20,
        CTRL_REG7_XL     = 0x21,
        CTRL_REG8        = 0x22,
        CTRL_REG9        = 0x23,
        CTRL_REG10       = 0x24,
        INT_GEN_SRC_XL   = 0x26,
        STATUS_REG_XL    = 0x27,
        OUT_X_L_XL       = 0x28,
        OUT_X_H_XL       = 0x29,
        OUT_Y_L_XL       = 0x2A,
        OUT_Y_H_XL       = 0x2B,
        OUT_Z_L_XL       = 0x2C,
        OUT_Z_H_XL       = 0x2D,
        FIFO_CTRL        = 0x2E,
        FIFO_SRC         = 0x2F,
        INT_GEN_CFG_G    = 0x30,
        INT_GEN_THS_XH_G = 0x31,
        INT_GEN_THS_XL_G = 0x32,
        INT_GEN_THS_YH_G = 0x33,
        INT_GEN_THS_YL_G = 0x34,
        INT_GEN_THS_ZH_G = 0x35,
        INT_GEN_THS_ZL_G = 0x36,
        INT_GEN_DUR_G    = 0x37
    };

    static const uint8_t INT1_CTRL_VAL      = 0x08;
    static const uint8_t WHO_AM_I_XLG_VAL   = 0x68;
    static const uint8_t CTRL_REG8_VAL      = 0x04;
    static const uint8_t CTRL_REG9_VAL      = 0x04;
    static const uint8_t FIFO_CTRL_VAL      = 0xC0;
    static const uint8_t FIFO_UNREAD_MASK   = 0x3F;
    static const uint8_t FIFO_OVERRUN_MASK  = 0x40;
    static const uint8_t SAMPLES_TO_DISCARD = 8;

    uint16_t fifo_num = 0;
};
